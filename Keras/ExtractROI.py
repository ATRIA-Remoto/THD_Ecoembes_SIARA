# -*- coding: utf-8 -*-
"""ObjectDetection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1j7OpW_yXrTs1CAgnl7Z61Za-eolSIdWl
"""

import cv2, os

def compute_iou(boxA, boxB):
  # determine the (x, y)-coordinates of the intersection rectangle
  xA = max(boxA[0], boxB[0])
  yA = max(boxA[1], boxB[1])
  xB = min(boxA[2], boxB[2])
  yB = min(boxA[3], boxB[3])
  # compute the area of intersection rectangle
  interArea = max(0, xB - xA + 1) * max(0, yB - yA + 1)
  # compute the area of both the prediction and ground-truth
  # rectangles
  boxAArea = (boxA[2] - boxA[0] + 1) * (boxA[3] - boxA[1] + 1)
  boxBArea = (boxB[2] - boxB[0] + 1) * (boxB[3] - boxB[1] + 1)
  # compute the intersection over union by taking the intersection
  # area and dividing it by the sum of prediction + ground-truth
  # areas - the intersection area
  iou = interArea / float(boxAArea + boxBArea - interArea)
  # return the intersection over union value
  return iou

def selective_search(image, method="fast"):
	# initialize OpenCV's selective search implementation and set the
	# input image
    ss = cv2.ximgproc.segmentation.createSelectiveSearchSegmentation()
    ss.setBaseImage(image)
    # check to see if we are using the *fast* but *less accurate* version
    # of selective search
    if method == "fast":
        ss.switchToSelectiveSearchFast()
    # otherwise we are using the *slower* but *more accurate* version
    else:
        ss.switchToSelectiveSearchQuality()
    # run selective search on the input image
    rects = ss.process()
    # return the region proposal bounding boxes
    return rects

def getBoxPoints(points):
    xtl = 9999.99
    xbr = 0.0
    ytl = 9999.99
    ybr = 0.0
    for (x, y) in points:
        if x < xtl:
            xtl = x
        elif x > xbr:
            xbr = x
        if y < ytl:
            ytl = y
        elif y > ybr:
            ybr = y
    return xtl, ytl, xbr, ybr

# COmprueba una ruta especicada y si no existe la crea.
def checkCreateFilePath(filename):
    if not os.path.exists(filename):
        os.makedirs(filename)

# Dibuja un rectangulo en los puntos indicados.
def pintarRectangulo(frame, bbox, color, tag=None, grosor=2):
    (x, y) = (int(bbox[0]), int(bbox[1]))
    (w, h) = (int(bbox[2]), int(bbox[3]))
    cv2.rectangle(frame, (x, y), (x + w, y + h), color, grosor)
    if tag is not None:
        cv2.putText(frame, tag, (x, y - 5), cv2.FONT_HERSHEY_SIMPLEX,0.5, color, grosor)
    return frame

PATH = 'D:\Proyectos\THD_Ecoembes\Imagenes/prueba_roi'

for i, f in enumerate(os.listdir(PATH)):
    print(str(i) + ' - ' + f)
    img = cv2.imread(os.path.join(PATH, f))
    img = cv2.resize(img, (300,300))
    (H, W) = img.shape[:2]
    cv2.imshow('img', img)
    cv2.waitKey(1)
    rects = selective_search(img, method='fast')
    j = 0
    for (x,y,w,h) in rects:
        print(str(j))
        if w / float(W) > 0.3 and h / float(H) > 0.3:
            imgAux = pintarRectangulo(img, (x,y,w,h), (0,255,0))
            cv2.imshow('rects', imgAux)
            cv2.waitKey(0)
            j = j + 1
            if j == 10:
                break